* R programming

** Programming with functions

*** How to get all function call parameters as a list?

    Call =as.list(match.call())[-1]= within your function

    #+begin_src R
      mydummyfun <- function(x, y, main = NULL, ...) {
	l <- as.list(match.call())[-1]
	do.call(plot, l)
      }

      mydummyfun(1:10, 1:10, ylab = "Ex")
    #+end_src

    Source: [[https://stackoverflow.com/a/11892680/2860744][Get all Parameters as List]]

    If you want to pass all the arguments to a new function:
    use =match.call= to get the complete call, and inject
    the name of the new function, and evaluate the modified call.


    #+begin_src R
      f1 <- function(a, b, c) { sum(a, b, c^2) }

      f2 <- function(a, b, c) { prod(a, b, c) }

      f  <- function(a, b, c) {
	fun <- f1
	if (a < 0)
	  fun <- f2

	thiscall      <- match.call(expand.dots = TRUE) # get the call (fun and args)
	thiscall[[1]] <- fun                            # change function name
	eval.parent(thiscall)                           # evaluate new call
					      # same as fun(a, b, c)
      }

      f(+1, 0, 5)
      f(-1, 0, 5)
    #+end_src

    Source: [[https://stackoverflow.com/a/56811164/2860744][Passing all arguments to another function]]

*** How to add a hook to a function call?

    Use =trace= to get execute an expression after and before a
    function call.

    #+begin_src R
      f_before <- function() { print("Before call") }
      f_after  <- function() { print("After  call") }

      trace(base::cumsum, f_before, f_after, print = FALSE)
      cumsum(1:10)

      untrace(base::cumsum)
      cumsum(1:10)
    #+end_src

*** How to mimic function overloading?

    Unfortunately, I haven't found anything better than optional
    arguments. See for example [[https://github.com/wch/r-source/blob/bba8fa69246ea248da33a566f463196614bb5242/src/library/grDevices/R/xyz.coords.R#L21][?xy.coords]]. In some situations, there
    might be better approaches.

    Source: [[https://stackoverflow.com/a/9266265/2860744][R - Function overloading]]

** How to create a sequence within groups?

   #+begin_src R
     x <- unlist(replicate(10, rep(sample(LETTERS, 1), rpois(1, 4))))
     sequence(rle(x)$lengths)                  # if ordered
     unlist(sapply(unname(table(x)), seq.int)) # doesn't need ordering
   #+end_src

   Source: [[https://stackoverflow.com/a/18815118/2860744][generate sequence within group in R]]

** How to identify value changes in a sequence?

   #+begin_src R
     x <- unlist(replicate(10, rep(sample(LETTERS, 1), rpois(1, 4))))
     head(cumsum(rle(x)$lengths)+1, -1)
   #+end_src

   Source: [[https://stackoverflow.com/a/45154771/2860744][Identifying where value changes in R data.frame column]]

** How to renumber a group?

   Note that =as.numeric(as.factor(x))= does not work if =x= contains
   numbers. Also, the match-unique combo scales better with large
   vectors.

   #+begin_src R
     x <- c(4, 4, 4, 6, 6, 6, 6, 8, 8, 8, 8, 1, 1, 1, 5, 5, 5, 5)
     match(x, unique(x))
					     # [1] 1 1 1 2 2 2 2 3 3 3 3 4 4 4 5 5 5 5
   #+end_src

   Source: [[https://stackoverflow.com/a/6113019/2860744][how to create a consecutive group number]]

** How to make a cross table with a custom function (e.g., mean)?

   #+begin_src R
     addmargins(xtabs(value ~ ., aggregate(value ~ factor1, factor2, DF, mean)),
		FUN = mean)
   #+end_src

** How to make lapply return a data.frame?

   If =x= is a =data.frame=, which is a list with attributes, use =x[]=
   to preserve all attributes.

   #+begin_src R
     x[] = lapply(x, type.convert)
   #+end_src

   Source: [[https://github.com/J-Moravec][Jiří Moravec]]

** How to split a matrix row-wise as a list?

   Use =base::asplit= for efficiency, where =asplit(X, 1)= and
   =asplit(X, 2)= return a list of rows and columns respectively.

   #+begin_src R
					     # I just learned about asplit
     asplit(X, 1)

					     # Original note
     X <- matrix(rnorm(100), nrow = 20)
     l <- as.list(as.data.frame(t(X)))
   #+end_src

** Look up a value among possibilities?

   The workhorse of any labeling function

   #+begin_src R
     l <- list(key1 = "value1", key2 = NA, key3 = 022)
     lookup <- function(x, l) { unlist(l[x]) }
   #+end_src

   Source: [[https://gist.github.com/luisdamiano/c8dc80775970e3159b6d4282e1bd85dd][benchmark unlist versus do.call(c, list) for list lookup in R]]

** How to remove columns with all NA fast?

   General approach with Base R only

   #+begin_src R
     Filter(function(x)!all(is.na(x)), df)
   #+end_src

   Via data.table for general time and memory efficiency (40% faster in example)

   #+begin_src R
     DT[, which(unlist(lapply(DT, function(x)!all(is.na(x))))), with = FALSE]
   #+end_src

   Source: [[https://stackoverflow.com/a/12614723/2860744][remove columns from dataframe where ALL values are NA]]

** How to fast subset rows corresponding to max value by group?

   #+begin_src R
					     # Row with maximum `g` for each group `id` in the `bdt` data.table
     bdt[bdt[, .I[g == max(g)], by = id]$V1]
   #+end_src

   Source: [[https://stackoverflow.com/a/16574176/2860744][subset rows corresponding to max value by group using data.table]]

** How to create named vector programatically in one statement?

   #+begin_src R
     out <- setNames(c("value1", "value2"), c("name1", "name2"))
   #+end_src

   Source: [[https://stackoverflow.com/a/22428439/2860744][create a numeric vector with names in one statement?]]

** How to get all function call arguments as a list?

   Including ellipsis also!

   #+begin_src R
     f <- function(a, b = 2, ...) { c(as.list(environment()), list(...)) }
   #+end_src

   Source: [[https://stackoverflow.com/a/17244041][get all Parameters as List]]

** How to debug an error thrown in a package?

   #+begin_src R
     options(error = recover, show.error.locations = TRUE, warn = 2)
   #+end_src

   Source: [[https://stackoverflow.com/a/13456223/2860744][debugging unexpected errors in R -- how can I find where the
   error occurred?]]

** How to draw a plot with minimal margins?

   #+begin_src R
					     # oma: Outer  = device margin lines (bltr)
					     # mar: Margin = figure margin lines (bltr)
					     # mgp:      ? = axis margin lines (title, label, line)

					     # No title
     opar <- par(
       oma = c(0, 0, 0, 0) + .1,
       mar = c(3, 3, 0, 0),
       mgp = c(2, 1, 0)
     )

     plot(x = 1:10, y = 1:10)

					     # No title nor axis labels
     opar <- par(
       oma = c(0, 0, 0, 0) + .1,
       mar = c(2, 2, 0, 0),
       mgp = c(2, 1, 0)
     )

     plot(x = 1:10, y = 1:10)
   #+end_src

** How to check if a value is in an interval?

   #+begin_src R
					     # x <- 1
					     # confint <- c(-0.5, 0.5)
     (prod(sign(confint - x)) < 0)
   #+end_src

   Source: rickyrick at libera.chat

** How to plot in log scale with base R?

   #+begin_src R
     plot(exp(1:10), 1:10, log = "x")
     plot(1:10, exp(1:10), log = "y")
     plot(exp(1:10), exp(1:10), log = "xy")
   #+end_src

** How to fine tune R plot margins?

   - [[https://www.rstudio.com/wp-content/uploads/2016/10/how-big-is-your-graph.pdf][How Big is Your Graph?]]

** How to make beautiful plots with base R?

   - [[http://karolis.koncevicius.lt/posts/r_base_plotting_without_wrappers/][R base plotting without wrappers]]

** Resources

   - [[https://pj.freefaculty.org/R/Rtips.html][Rtips]]
   - [[http://karolis.koncevicius.lt/posts/collection_of_simple_r_shortcuts/][A Collection of Simple R Shortcuts]]
   - [[https://csgillespie.github.io/efficientR/set-up.html#blas-and-alternative-r-interpreters][Efficient R programming]]
